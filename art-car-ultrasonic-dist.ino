// simple project using Arduino UNO and 128x64 OLED Display for rear parking sensor
// project due to GREAT work by upir!!!
// created by upir, 2022, modified by bradcarlile 2024
//
// Brad Changes
// * orginal design was for rear sensors, did minimal rotation so can just rotate display
// * rotated art car text by 180,
// * rotated cm/in & sound by 180 and switched sides
// * rotated numeric distance labels by 180, recalced position of text in floating black box
// * added turning off of arduino's interrupt handling during sound return measurement
// * added Bounce2 for two buttons to switch rear/front & in/cm
//   https://github.com/thomasfredericks/Bounce2/blob/master/examples/more/change/change.ino
// * added dht22 sensor & temp & humidity speed of sound correction
// * print out temp in the place of sound sensor

// youtube channel: https://www.youtube.com/upir_upir
// youtube full video: https://youtu.be/gg08H-6Z1Lo
// Github: https://github.com/upiir/arduino_parking_sensor
// full simulation https://wokwi.com/projects/348388602879672914

// u8g fonts (fonts available for u8g library): https://nodemcu-build.com/u8g-fonts.php
// u8g documentation: https://github.com/olikraus/u8glib/wiki/userreference
// image2cpp (convert images into C code): https://javl.github.io/image2cpp/

// useful links:
// u8g documentation: https://github.com/olikraus/u8glib/wiki/userreference

#include "U8glib.h"
#include <Bounce2.h>
#include "DHT_Async.h"

// image2cpp (convert png into C code): https://javl.github.io/image2cpp/
// for rear sensor
// 'art-car-imag', 56x15px
const unsigned char bitmap_artcar_image[] PROGMEM = {
  0xc9, 0x04, 0x59, 0x11, 0x0c, 0x08, 0x43, 0xc8, 0x82, 0x8e, 0x90, 0x93, 0x10, 0x93, 0xe0, 0x63,
  0x00, 0x78, 0xe0, 0xe3, 0x07, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xc0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x03, 0x40, 0x1c, 0xf3, 0xe3, 0x8e, 0x78, 0x02, 0x47, 0x22, 0x88, 0x84, 0x51, 0x44,
  0xe2, 0x45, 0x22, 0x88, 0x84, 0x11, 0x44, 0xa2, 0x47, 0x22, 0xf0, 0x84, 0x11, 0x78, 0xe2, 0x20,
  0x3e, 0x88, 0x84, 0x1f, 0x44, 0x04, 0x10, 0x22, 0x88, 0x84, 0x51, 0x44, 0x08, 0x0c, 0x22, 0x88,
  0x83, 0x91, 0x44, 0x30, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0xff, 0xff, 0xff, 0xff,
  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// for front sensor
// 'art-car-image-flip', 56x15px
const unsigned char bitmap_artcar_image_flip[] PROGMEM = {
  0xc9, 0x04, 0x59, 0x11, 0x0c, 0x08, 0x43, 0xc8, 0x82, 0x8e, 0x90, 0x93, 0x10, 0x93, 0xe0, 0x63,
  0x00, 0x78, 0xe0, 0xe3, 0x07, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xc0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x03, 0x40, 0x22, 0x89, 0xc1, 0x11, 0x44, 0x02, 0x47, 0x22, 0x8a, 0x21, 0x11, 0x44,
  0xe2, 0x45, 0x22, 0xf8, 0x21, 0x11, 0x7c, 0xa2, 0x47, 0x1e, 0x88, 0x21, 0x0f, 0x44, 0xe2, 0x20,
  0x22, 0x88, 0x21, 0x11, 0x44, 0x04, 0x10, 0x22, 0x8a, 0x21, 0x11, 0x44, 0x08, 0x0c, 0x1e, 0x71,
  0xc7, 0xcf, 0x38, 0x30, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0xff, 0xff, 0xff, 0xff,
  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'sensor_01_a_off', 32x14px
const unsigned char bitmap_sensor_01_a_off[] PROGMEM = {
  0x00, 0x40, 0x00, 0x00, 0x02, 0xa8, 0x00, 0x00, 0x05, 0x55, 0x00, 0x00, 0x02, 0xaa, 0xa0, 0x00,
  0x05, 0x55, 0x54, 0x00, 0x0a, 0xaa, 0xaa, 0xa0, 0x15, 0x55, 0x55, 0x50, 0x0a, 0xaa, 0xaa, 0xa0,
  0x01, 0x55, 0x55, 0x40, 0x00, 0x2a, 0xaa, 0xa0, 0x00, 0x15, 0x55, 0x40, 0x00, 0x02, 0xaa, 0xa0,
  0x00, 0x00, 0x15, 0x40, 0x00, 0x00, 0x02, 0xa0
};
// 'sensor_01_a_on', 32x14px
const unsigned char bitmap_sensor_01_a_on[] PROGMEM = {
  0x00, 0xc0, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x07, 0xff, 0x00, 0x00, 0x07, 0xff, 0xe0, 0x00,
  0x0f, 0xff, 0xfe, 0x00, 0x0f, 0xff, 0xff, 0xf0, 0x1f, 0xff, 0xff, 0xf0, 0x0f, 0xff, 0xff, 0xe0,
  0x03, 0xff, 0xff, 0xe0, 0x00, 0x7f, 0xff, 0xe0, 0x00, 0x1f, 0xff, 0xe0, 0x00, 0x03, 0xff, 0xe0,
  0x00, 0x00, 0x3f, 0xe0, 0x00, 0x00, 0x03, 0xe0
};
// 'sensor_01_b_off', 32x16px
const unsigned char bitmap_sensor_01_b_off[] PROGMEM = {
  0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x02, 0xa0, 0x00, 0x00, 0x05, 0x54, 0x00, 0x00,
  0x0a, 0xaa, 0x80, 0x00, 0x15, 0x55, 0x50, 0x00, 0x0a, 0xaa, 0xaa, 0x80, 0x15, 0x55, 0x55, 0x50,
  0x0a, 0xaa, 0xaa, 0xa8, 0x05, 0x55, 0x55, 0x50, 0x00, 0xaa, 0xaa, 0xa8, 0x00, 0x15, 0x55, 0x50,
  0x00, 0x02, 0xaa, 0xa0, 0x00, 0x00, 0x55, 0x50, 0x00, 0x00, 0x0a, 0xa0, 0x00, 0x00, 0x00, 0x50
};
// 'sensor_01_b_on', 32x16px
const unsigned char bitmap_sensor_01_b_on[] PROGMEM = {
  0x02, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x07, 0xf0, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00,
  0x0f, 0xff, 0x80, 0x00, 0x1f, 0xff, 0xf8, 0x00, 0x1f, 0xff, 0xff, 0x80, 0x3f, 0xff, 0xff, 0xf8,
  0x1f, 0xff, 0xff, 0xf8, 0x07, 0xff, 0xff, 0xf8, 0x01, 0xff, 0xff, 0xf8, 0x00, 0x3f, 0xff, 0xf8,
  0x00, 0x07, 0xff, 0xf0, 0x00, 0x00, 0xff, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0xf0
};
// 'sensor_01_c_off', 32x17px
const unsigned char bitmap_sensor_01_c_off[] PROGMEM = {
  0x08, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x00, 0x00, 0x15, 0x50, 0x00, 0x00,
  0x2a, 0xaa, 0x00, 0x00, 0x15, 0x55, 0x40, 0x00, 0x2a, 0xaa, 0xaa, 0x00, 0x55, 0x55, 0x55, 0x40,
  0x2a, 0xaa, 0xaa, 0xaa, 0x15, 0x55, 0x55, 0x54, 0x02, 0xaa, 0xaa, 0xa8, 0x00, 0x55, 0x55, 0x54,
  0x00, 0x0a, 0xaa, 0xa8, 0x00, 0x01, 0x55, 0x54, 0x00, 0x00, 0x2a, 0xa8, 0x00, 0x00, 0x05, 0x54,
  0x00, 0x00, 0x00, 0x28
};
// 'sensor_01_c_on', 32x17px
const unsigned char bitmap_sensor_01_c_on[] PROGMEM = {
  0x08, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00,
  0x3f, 0xff, 0x00, 0x00, 0x3f, 0xff, 0xe0, 0x00, 0x7f, 0xff, 0xfe, 0x00, 0x7f, 0xff, 0xff, 0xe0,
  0x7f, 0xff, 0xff, 0xfe, 0x1f, 0xff, 0xff, 0xfe, 0x03, 0xff, 0xff, 0xfc, 0x00, 0xff, 0xff, 0xfc,
  0x00, 0x1f, 0xff, 0xfc, 0x00, 0x03, 0xff, 0xfc, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x07, 0xfc,
  0x00, 0x00, 0x00, 0x3c
};
// 'sensor_01_d_off', 32x18px
const unsigned char bitmap_sensor_01_d_off[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 0x2a, 0x80, 0x00, 0x00,
  0x55, 0x50, 0x00, 0x00, 0xaa, 0xaa, 0x00, 0x00, 0x55, 0x55, 0x50, 0x00, 0xaa, 0xaa, 0xaa, 0x00,
  0x55, 0x55, 0x55, 0x50, 0x2a, 0xaa, 0xaa, 0xaa, 0x05, 0x55, 0x55, 0x54, 0x02, 0xaa, 0xaa, 0xaa,
  0x00, 0x55, 0x55, 0x54, 0x00, 0x0a, 0xaa, 0xaa, 0x00, 0x01, 0x55, 0x54, 0x00, 0x00, 0x2a, 0xa8,
  0x00, 0x00, 0x01, 0x54, 0x00, 0x00, 0x00, 0x08
};
// 'sensor_02_a_off', 32x9px
const unsigned char bitmap_sensor_02_a_off[] PROGMEM = {
  0x05, 0x55, 0x55, 0x40, 0x0a, 0xaa, 0xaa, 0xa0, 0x05, 0x55, 0x55, 0x40, 0x0a, 0xaa, 0xaa, 0xa0,
  0x05, 0x55, 0x55, 0x40, 0x0a, 0xaa, 0xaa, 0xa0, 0x05, 0x55, 0x55, 0x40, 0x0a, 0xaa, 0xaa, 0xa0,
  0x15, 0x55, 0x55, 0x50
};
// 'sensor_01_d_on', 32x18px
const unsigned char bitmap_sensor_01_d_on[] PROGMEM = {
  0x20, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x7f, 0xc0, 0x00, 0x00,
  0xff, 0xf8, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x00, 0xff, 0xff, 0xfe, 0x00,
  0x7f, 0xff, 0xff, 0xf0, 0x3f, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xfe, 0x03, 0xff, 0xff, 0xfe,
  0x00, 0x7f, 0xff, 0xfe, 0x00, 0x1f, 0xff, 0xfe, 0x00, 0x01, 0xff, 0xfc, 0x00, 0x00, 0x3f, 0xfc,
  0x00, 0x00, 0x03, 0xfc, 0x00, 0x00, 0x00, 0x1c
};
// 'sensor_02_a_on', 32x9px
const unsigned char bitmap_sensor_02_a_on[] PROGMEM = {
  0x07, 0xff, 0xff, 0xc0, 0x0f, 0xff, 0xff, 0xe0, 0x0f, 0xff, 0xff, 0xe0, 0x0f, 0xff, 0xff, 0xe0,
  0x0f, 0xff, 0xff, 0xe0, 0x0f, 0xff, 0xff, 0xe0, 0x0f, 0xff, 0xff, 0xe0, 0x0f, 0xff, 0xff, 0xe0,
  0x1f, 0xff, 0xff, 0xf0
};
// 'sensor_02_b_off', 32x9px
const unsigned char bitmap_sensor_02_b_off[] PROGMEM = {
  0x15, 0x55, 0x55, 0x50, 0x0a, 0xaa, 0xaa, 0xa0, 0x15, 0x55, 0x55, 0x50, 0x0a, 0xaa, 0xaa, 0xa0,
  0x15, 0x55, 0x55, 0x50, 0x2a, 0xaa, 0xaa, 0xa8, 0x15, 0x55, 0x55, 0x50, 0x2a, 0xaa, 0xaa, 0xa8,
  0x05, 0x55, 0x55, 0x40
};
// 'sensor_02_b_on', 32x9px
const unsigned char bitmap_sensor_02_b_on[] PROGMEM = {
  0x1f, 0xff, 0xff, 0xf0, 0x1f, 0xff, 0xff, 0xf0, 0x1f, 0xff, 0xff, 0xf0, 0x1f, 0xff, 0xff, 0xf0,
  0x3f, 0xff, 0xff, 0xf8, 0x3f, 0xff, 0xff, 0xf8, 0x3f, 0xff, 0xff, 0xf8, 0x3f, 0xff, 0xff, 0xf8,
  0x0f, 0xff, 0xff, 0xe0
};
// 'sensor_02_c_off', 32x10px
const unsigned char bitmap_sensor_02_c_off[] PROGMEM = {
  0x10, 0x00, 0x00, 0x04, 0x0a, 0xaa, 0xaa, 0xa8, 0x15, 0x55, 0x55, 0x54, 0x2a, 0xaa, 0xaa, 0xaa,
  0x15, 0x55, 0x55, 0x54, 0x2a, 0xaa, 0xaa, 0xaa, 0x15, 0x55, 0x55, 0x54, 0x2a, 0xaa, 0xaa, 0xaa,
  0x15, 0x55, 0x55, 0x54, 0x0a, 0xaa, 0xaa, 0xa8
};
// 'sensor_02_c_on', 32x10px
const unsigned char bitmap_sensor_02_c_on[] PROGMEM = {
  0x18, 0x00, 0x00, 0x0c, 0x1f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfe, 0x3f, 0xff, 0xff, 0xfe,
  0x3f, 0xff, 0xff, 0xfe, 0x3f, 0xff, 0xff, 0xfe, 0x3f, 0xff, 0xff, 0xfe, 0x3f, 0xff, 0xff, 0xfe,
  0x3f, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xf8
};
// 'sensor_02_d_off', 40x10px
const unsigned char bitmap_sensor_02_d_off[] PROGMEM = {
  0x02, 0x80, 0x00, 0x00, 0x28, 0x01, 0x55, 0x55, 0x55, 0x50, 0x02, 0xaa, 0xaa, 0xaa, 0xa8, 0x01,
  0x55, 0x55, 0x55, 0x50, 0x02, 0xaa, 0xaa, 0xaa, 0xa8, 0x05, 0x55, 0x55, 0x55, 0x54, 0x02, 0xaa,
  0xaa, 0xaa, 0xa8, 0x05, 0x55, 0x55, 0x55, 0x54, 0x02, 0xaa, 0xaa, 0xaa, 0xa8, 0x00, 0x55, 0x55,
  0x55, 0x40
};
// 'sensor_02_d_on', 40x10px
const unsigned char bitmap_sensor_02_d_on[] PROGMEM = {
  0x03, 0x80, 0x00, 0x00, 0x38, 0x03, 0xff, 0xff, 0xff, 0xf8, 0x03, 0xff, 0xff, 0xff, 0xf8, 0x03,
  0xff, 0xff, 0xff, 0xf8, 0x03, 0xff, 0xff, 0xff, 0xf8, 0x07, 0xff, 0xff, 0xff, 0xfc, 0x07, 0xff,
  0xff, 0xff, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xfc, 0x00, 0xff, 0xff,
  0xff, 0xe0
};
// 'sensor_03_a_off', 32x14px
const unsigned char bitmap_sensor_03_a_off[] PROGMEM = {
  0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x2a, 0x80, 0x00, 0x01, 0x55, 0x40, 0x00, 0x0a, 0xaa, 0x80,
  0x00, 0x55, 0x55, 0x40, 0x0a, 0xaa, 0xaa, 0xa0, 0x15, 0x55, 0x55, 0x50, 0x0a, 0xaa, 0xaa, 0xa0,
  0x05, 0x55, 0x55, 0x00, 0x0a, 0xaa, 0xa8, 0x00, 0x05, 0x55, 0x50, 0x00, 0x0a, 0xaa, 0x80, 0x00,
  0x05, 0x50, 0x00, 0x00, 0x0a, 0x80, 0x00, 0x00
};
// 'sensor_03_b_on', 32x16px
const unsigned char bitmap_sensor_03_b_on[] PROGMEM = {
  0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x3f, 0xf0,
  0x00, 0x01, 0xff, 0xf0, 0x00, 0x1f, 0xff, 0xf8, 0x01, 0xff, 0xff, 0xf8, 0x1f, 0xff, 0xff, 0xfc,
  0x1f, 0xff, 0xff, 0xf8, 0x1f, 0xff, 0xff, 0xe0, 0x1f, 0xff, 0xff, 0x80, 0x1f, 0xff, 0xfc, 0x00,
  0x0f, 0xff, 0xe0, 0x00, 0x0f, 0xff, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00
};
// 'sensor_03_a_on', 32x14px
const unsigned char bitmap_sensor_03_a_on[] PROGMEM = {
  0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x3f, 0x80, 0x00, 0x01, 0xff, 0xc0, 0x00, 0x0f, 0xff, 0xc0,
  0x00, 0xff, 0xff, 0xe0, 0x1f, 0xff, 0xff, 0xe0, 0x1f, 0xff, 0xff, 0xf0, 0x0f, 0xff, 0xff, 0xe0,
  0x0f, 0xff, 0xff, 0x80, 0x0f, 0xff, 0xfc, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x0f, 0xff, 0x80, 0x00,
  0x0f, 0xf8, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00
};
// 'sensor_03_b_off', 32x16px
const unsigned char bitmap_sensor_03_b_off[] PROGMEM = {
  0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x05, 0x40, 0x00, 0x00, 0x2a, 0xa0,
  0x00, 0x01, 0x55, 0x50, 0x00, 0x0a, 0xaa, 0xa8, 0x01, 0x55, 0x55, 0x50, 0x0a, 0xaa, 0xaa, 0xa8,
  0x15, 0x55, 0x55, 0x50, 0x0a, 0xaa, 0xaa, 0xa0, 0x15, 0x55, 0x55, 0x00, 0x0a, 0xaa, 0xa8, 0x00,
  0x05, 0x55, 0x40, 0x00, 0x0a, 0xaa, 0x00, 0x00, 0x05, 0x50, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00
};
// 'sensor_03_c_off', 32x17px
const unsigned char bitmap_sensor_03_c_off[] PROGMEM = {
  0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x01, 0x50, 0x00, 0x00, 0x0a, 0xa8,
  0x00, 0x00, 0x55, 0x54, 0x00, 0x02, 0xaa, 0xa8, 0x00, 0x55, 0x55, 0x54, 0x02, 0xaa, 0xaa, 0xaa,
  0x55, 0x55, 0x55, 0x54, 0x2a, 0xaa, 0xaa, 0xa8, 0x15, 0x55, 0x55, 0x40, 0x2a, 0xaa, 0xaa, 0x00,
  0x15, 0x55, 0x50, 0x00, 0x2a, 0xaa, 0x80, 0x00, 0x15, 0x54, 0x00, 0x00, 0x2a, 0xa0, 0x00, 0x00,
  0x14, 0x00, 0x00, 0x00
};
// 'sensor_03_d_on', 32x18px
const unsigned char bitmap_sensor_03_d_on[] PROGMEM = {
  0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x07, 0xfc,
  0x00, 0x00, 0x3f, 0xfe, 0x00, 0x01, 0xff, 0xfe, 0x00, 0x1f, 0xff, 0xfe, 0x00, 0xff, 0xff, 0xfe,
  0x1f, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0x80,
  0xff, 0xff, 0xfc, 0x00, 0xff, 0xff, 0xf0, 0x00, 0x7f, 0xff, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x00,
  0x7f, 0x80, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00
};
// 'sensor_03_d_off', 32x18px
const unsigned char bitmap_sensor_03_d_off[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x01, 0x54, 0x00, 0x00, 0x02, 0xa8,
  0x00, 0x00, 0x15, 0x54, 0x00, 0x00, 0xaa, 0xaa, 0x00, 0x15, 0x55, 0x54, 0x00, 0xaa, 0xaa, 0xaa,
  0x15, 0x55, 0x55, 0x54, 0xaa, 0xaa, 0xaa, 0xa8, 0x55, 0x55, 0x55, 0x40, 0xaa, 0xaa, 0xaa, 0x80,
  0x55, 0x55, 0x54, 0x00, 0xaa, 0xaa, 0xa0, 0x00, 0x55, 0x55, 0x00, 0x00, 0x2a, 0xa8, 0x00, 0x00,
  0x55, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00
};
// 'sensor_03_c_on', 32x17px
const unsigned char bitmap_sensor_03_c_on[] PROGMEM = {
  0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x1f, 0xf8,
  0x00, 0x00, 0xff, 0xfc, 0x00, 0x07, 0xff, 0xfc, 0x00, 0x7f, 0xff, 0xfe, 0x07, 0xff, 0xff, 0xfe,
  0x7f, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xf8, 0x3f, 0xff, 0xff, 0xc0, 0x3f, 0xff, 0xff, 0x00,
  0x3f, 0xff, 0xf8, 0x00, 0x3f, 0xff, 0xc0, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x3f, 0xe0, 0x00, 0x00,
  0x3c, 0x00, 0x00, 0x00
};
// rear 'unit_cm', 24x10px
const unsigned char bitmap_unit_cm[] PROGMEM = {
  0xf0, 0x03, 0xc0, 0x80, 0x00, 0x40, 0xbe, 0xff, 0x40, 0xb6, 0xdb, 0x40, 0x30, 0xdb, 0x00, 0x30,
  0xdb, 0x00, 0xb6, 0xdb, 0x40, 0xbe, 0xdb, 0x40, 0x80, 0x00, 0x40, 0xf0, 0x03, 0xc0
};
// front 'cm-flip', 24x10px
const unsigned char bitmap_unit_cm_flip[] PROGMEM = {
  0x03, 0xc0, 0x0f, 0x02, 0x00, 0x01, 0x02, 0xdb, 0x7d, 0x02, 0xdb, 0x6d, 0x00, 0xdb, 0x0c, 0x00,
  0xdb, 0x0c, 0x02, 0xdb, 0x6d, 0x02, 0xff, 0x7d, 0x02, 0x00, 0x01, 0x03, 0xc0, 0x0f
};
// 'unit in', 24x10px
const unsigned char bitmap_unit_in[] PROGMEM = {
  0xf0, 0x03, 0xc0, 0x80, 0x00, 0x40, 0x8c, 0x7c, 0x40, 0x8c, 0x6c, 0x40, 0x0c, 0x6c, 0x00, 0x0c,
  0x6c, 0x00, 0x8c, 0x6c, 0x40, 0x8c, 0x6c, 0x40, 0x80, 0x00, 0x40, 0xf0, 0x03, 0xc0
};
// 'in-flip', 24x10px
const unsigned char bitmap_unit_in_flip[] PROGMEM = {
  0x03, 0xc0, 0x0f, 0x02, 0x00, 0x01, 0x02, 0x36, 0x31, 0x02, 0x36, 0x31, 0x00, 0x36, 0x30, 0x00,
  0x36, 0x30, 0x02, 0x36, 0x31, 0x02, 0x3e, 0x31, 0x02, 0x00, 0x01, 0x03, 0xc0, 0x0f
};
// 'degree-temp', 24x10px
const unsigned char degree_temp[] PROGMEM = {
  0xf0, 0x00, 0x0f, 0x80, 0x00, 0x01, 0x80, 0x00, 0x0d, 0x80, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0xf0, 0x00, 0x0f
};
// 'degree-temp_flip', 24x10px
const unsigned char degree_temp_flip[] PROGMEM = {
  0xf0, 0x00, 0x0f, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xb0, 0x00, 0x01, 0xb0, 0x00, 0x01, 0x80, 0x00, 0x01, 0xf0, 0x00, 0x0f
};
// 'neg', 3x1px
const unsigned char bitmap_neg[] PROGMEM = {
  0xe0
};

/*
  Fontname: gamer_digits
  Copyright: Created with Fony 1.4.7
  Capital A Height: 0, '1' Height: 6
  Calculated Max Values w= 5 h= 6 x= 1 y= 0 dx= 6 dy= 0 ascent= 0 len= 6
  Font Bounding box     w= 9 h= 5 x= 0 y=-6
  Calculated Min Values           x= 0 y=-6 dx= 0 dy= 0
  Pure Font   ascent = 6 descent= 0
  X Font      ascent = 6 descent= 0
  Max Font    ascent = 0 descent=-6
*/
const u8g_fntpgm_uint8_t gamer_digits[137] U8G_FONT_SECTION("gamer_digits") = {
  0, 9, 5, 0, 250, 6, 0, 0, 0, 0, 48, 57, 0, 0, 250, 6,
  0, 5, 6, 6, 6, 0, 250, 248, 216, 216, 216, 216, 248, 4, 6, 6,
  6, 1, 250, 224, 96, 96, 96, 96, 240, 5, 6, 6, 6, 0, 250, 248,
  24, 120, 192, 192, 248, 5, 6, 6, 6, 0, 250, 248, 24, 248, 24, 216,
  248, 5, 6, 6, 6, 0, 250, 56, 120, 216, 248, 24, 24, 5, 6, 6,
  6, 0, 250, 248, 192, 248, 24, 24, 248, 5, 6, 6, 6, 0, 250, 248,
  192, 248, 216, 216, 248, 5, 6, 6, 6, 0, 250, 248, 24, 24, 24, 24,
  24, 5, 6, 6, 6, 0, 250, 248, 216, 248, 216, 216, 248, 5, 6, 6,
  6, 0, 250, 248, 216, 216, 248, 24, 248
};

// I2C version
//U8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_DEV_0 | U8G_I2C_OPT_NO_ACK | U8G_I2C_OPT_FAST);  // Fast I2C / TWI
// SDA version
U8GLIB_SSD1306_128X64 u8g(13, 11, 10, 9, 8);  // SDA
#define DHT_SENSOR_TYPE DHT_TYPE_22

// set pins for the distance sensors, and two buttons
// pin 19  << OPEN >> I2C SCL aka A5
// pin 18  << OPEN >> I2C SDA aka A4
// pin 17  << OPEN >> aka A3  ? DS18B20 waterproof External temp ?
// pin 16  << OPEN >> aka A2
#define button2Pin 15  // aka pin A1, using as digital
#define button1Pin 14  // aka pin A0, using as digital
// pin 13 SDA SCK
static const int DHT_SENSOR_PIN = 12;
// pin 11 SDA MOSI
// pin 10 SDA CS
// pin 9 SDA DC
// pin 8 SDA RES
#define sensor_01_TRIG_PIN 7
#define sensor_01_ECHO_PIN 6
#define sensor_02_TRIG_PIN 5
#define sensor_02_ECHO_PIN 4
#define sensor_03_TRIG_PIN 3
#define sensor_03_ECHO_PIN 2

// start Sensor
DHT_Async dht_sensor(DHT_SENSOR_PIN, DHT_SENSOR_TYPE);

// Instantiate a Bounce object for debouncing buttons
Bounce debouncer1 = Bounce();  // Instantiate a Bounce object
Bounce debouncer2 = Bounce();  // Instantiate a second Bounce object
bool rearSensors = false;      // start with front sensors
bool inches = true;            // start with inches

// number of sensors - image drawing is hardcoded, changing # sensor is complicated
#define NUMBER_OF_SENSORS 3

struct sensor_data {         // structure for the sensor data
  int echo_pin;              // ECHO pin for the ultrasonic distance sensor
  int trig_pin;              // TRIG pin for the ultrasonic distance sensor
  long measured_ms;          // measured milliseconds
  int measured_distance_cm;  // measured distance in CM
  int measured_distance_in;  // measured distance in in
  int label_xpos;            // x position of the distance label
  int label_ypos;            // y position of the distance label
  int label_width;           // calculated width of the distance string
  int label_startpos_x;      // start X position for the label
  int label_startpos_y;      // start Y position for the label
  int label_endpos_x;        // end X position for the label
  int label_endpos_y;        // end Y position for the label
};

char buffer[10];  // helper C-style array of chars to store ints converted to strings

struct sensor_data sensor[NUMBER_OF_SENSORS];  // we have 3 sensors for now

int min_dist = 2;    // min distance to display in cm, also the min distance for sensor
int max_dist = 100;  // max distance to display in cm with the tile images, max is 400cm = 4m
int dist_step_01;    // distance for the first tile (there are 4 tiles for each sensor)
int dist_step_02;    // distance for the 2nd tile
int dist_step_03;    // distance for the 3rd tile
int dist_step_04;    // distance for the 4th tile


float humidity;
float tempC;
float tempF;
int tempCint = 0;
int tempFint = 0;
bool negflag = true;
float soundSpeed = 344.11;  //Speed of sound initialized to 20C (68F) and 60% Rel Humidity

int loopCount = 0;
unsigned long loopMillis = 0;

#define debug true

void setup() {
  if (debug) {
    Serial.begin(115200);  // debug only, BTW 9600 baud slows code
    Serial.println("Starting...");
    Serial.print(" soundSpeed=");
    Serial.println(soundSpeed);
  }

  // Attach the debouncer to a pin with INPUT_PULLUP mode
  debouncer1.attach(button1Pin, INPUT_PULLUP);  // Attach the debouncer1 to a pin with INPUT_PULLUP mode
  debouncer2.attach(button2Pin, INPUT_PULLUP);  // debouncer1 to a pin with INPUT_PULLUP mode
  debouncer1.interval(25);                      // Use a debounce interval of 25 milliseconds
  debouncer2.interval(25);                      // debounce interval of 25 milliseconds

  // calculate individual steps for the 4 tiles
  // dist_step_01 = 27cm,  dist_step_02 = 51cm,  dist_step_03 = 76cm,  dist_step_04 = 100cm
  // dist_step_01 = 10.6", dist_step_02 = 20.1", dist_step_03 = 30.0", dist_step_04 = 39.4"
  dist_step_01 = min_dist + round((max_dist - min_dist) / 4.0 * 1.0);
  dist_step_02 = min_dist + round((max_dist - min_dist) / 4.0 * 2.0);
  dist_step_03 = min_dist + round((max_dist - min_dist) / 4.0 * 3.0);
  dist_step_04 = min_dist + round((max_dist - min_dist) / 4.0 * 4.0);

  // initialize pins for sensors
  sensor[0].echo_pin = sensor_01_ECHO_PIN;
  sensor[0].trig_pin = sensor_01_TRIG_PIN;
  sensor[1].echo_pin = sensor_02_ECHO_PIN;
  sensor[1].trig_pin = sensor_02_TRIG_PIN;
  sensor[2].echo_pin = sensor_03_ECHO_PIN;
  sensor[2].trig_pin = sensor_03_TRIG_PIN;

  // set pins to outputs and inputs  - trigger is output, echo is input
  pinMode(sensor[0].trig_pin, OUTPUT);
  pinMode(sensor[0].echo_pin, INPUT);
  pinMode(sensor[1].trig_pin, OUTPUT);
  pinMode(sensor[1].echo_pin, INPUT);
  pinMode(sensor[2].trig_pin, OUTPUT);
  pinMode(sensor[2].echo_pin, INPUT);

  // initialize label position data were manually defined in the Photoshop
  sensor[0].label_startpos_x = 41;
  sensor[0].label_startpos_y = 20;
  sensor[0].label_endpos_x = 30;
  sensor[0].label_endpos_y = 58;
  sensor[1].label_startpos_x = 63;
  sensor[1].label_startpos_y = 23;
  sensor[1].label_endpos_x = 63;
  sensor[1].label_endpos_y = 60;
  sensor[2].label_startpos_x = 85;
  sensor[2].label_startpos_y = 20;
  sensor[2].label_endpos_x = 97;
  sensor[2].label_endpos_y = 57;

  u8g.setFont(gamer_digits);  // gamer digits font, manually generated, only includes digits
  u8g.setColorIndex(1);       // white color
  loopMillis = millis();
}

/*
 * Only call every 4 seconds (done in main loop)
 * true if a measurement is available.
 */
static bool measure_environment(float *tempC, float *humidity) {

  /* Measure once every four seconds. */
  if (dht_sensor.measure(tempC, humidity)) {
    return (true);
  }
  return (false);
}

void loop() {
  //Every 4 seconds
  if ((millis() - loopMillis) > 4000) {
    //do this every 4 seconds,  ~100 loops
    if (measure_environment(&tempC, &humidity) == true) {
      tempF = (tempC * 9.0 / 5.0) + 32.0;
      tempCint = int(tempC + 0.5);
      tempFint = int(tempF + 0.5);
      soundSpeed = (20.05 * sqrt(273.16 + tempC)) + (0.0006545 * humidity + 0.00475) * tempC + (0.001057 * humidity + 0.07121);
    }
    if (debug) {
      Serial.print("millis=");
      Serial.print(millis());
      Serial.print("  #loops=");
      Serial.println(loopCount);
      Serial.print("tempC=");
      Serial.print(tempC);
      Serial.print(", tempF=");
      Serial.print(tempF);
      Serial.print(", humidity=");
      Serial.print(humidity);
      Serial.print(", soundSpeed=");
      Serial.println(soundSpeed);
    }
    loopMillis = millis();
    loopCount = 0;
  }

  // flip in/cm if button 2 transitions from HIGH to LOW
  debouncer2.update();  // Update the Bounce instance
  if (debouncer2.fell()) inches = !inches;

  // flip rear/fron if button 1 transitions from HIGH to LOW
  debouncer1.update();  // Update the Bounce instance
  if (debouncer1.fell()) {
    rearSensors = !rearSensors;
    (rearSensors) ? u8g.setRot180() : u8g.undoRotation();  // if rear, rotate physical screen
  }

  // For the 3 sensors
  for (int i = 0; i < NUMBER_OF_SENSORS; i++) {  // for each sensor
    // trigger the trigger pin for at least 10 microseconds
    digitalWrite(sensor[i].trig_pin, HIGH);
    delayMicroseconds(10);
    digitalWrite(sensor[i].trig_pin, LOW);

    // Read pulse duration: TURN OFF Arduino Interrupts during measurement improves accuracy
    // pulseIn is # of ms (type long) the pulse on each sensor
    noInterrupts();
    sensor[i].measured_ms = pulseIn(sensor[i].echo_pin, HIGH, 30000L);
    interrupts();

    // speed of sound = 343m/s, has to travel back and forth, that´s why we divide it by 2
    sensor[i].measured_distance_cm = round(sensor[i].measured_ms * (soundSpeed / 20000.0));
    sensor[i].measured_distance_in = round(sensor[i].measured_ms * (soundSpeed / 20000.0) / 2.54);

    // calculate string width
    itoa(sensor[i].measured_distance_cm, buffer, 10);  // convert integer to C-style string
    sensor[i].label_width = u8g.getStrWidth(buffer);

    // calculate label positions
    sensor[i].label_xpos = map(constrain(sensor[i].measured_distance_cm, min_dist, max_dist), min_dist, max_dist, sensor[i].label_startpos_x, sensor[i].label_endpos_x);
    sensor[i].label_ypos = map(constrain(sensor[i].measured_distance_cm, min_dist, max_dist), min_dist, max_dist, sensor[i].label_startpos_y, sensor[i].label_endpos_y);
  }

  u8g.firstPage();
  do {
    if (rearSensors) {
      u8g.drawBitmapP(36, 0, 56 / 8, 15, bitmap_artcar_image);  // car image on top of the display
      u8g.drawBitmapP(104, 0, 24 / 8, 10, degree_temp);         // 'degree-temp', 24x10px
      if (inches) {
        u8g.drawBitmapP(0, 0, 24 / 8, 10, bitmap_unit_in);
        itoa(tempFint, buffer, 10);
        (tempFint < 0) ? negflag = true : negflag = false;

      } else {
        u8g.drawBitmapP(0, 0, 24 / 8, 10, bitmap_unit_cm);
        itoa(tempCint, buffer, 10);
        (tempCint < 0) ? negflag = true : negflag = false;
      }
      (u8g.getStrWidth(buffer) == 18) ? u8g.drawStr(106, 2, buffer) : u8g.drawStr(112, 2, buffer);  // width px
      // if (negflag) u8g.drawBitmapP(110, 5, 3, 1, bitmap_neg);
    } else {
      u8g.drawBitmapP(36, 0, 56 / 8, 15, bitmap_artcar_image_flip);  // car image on top of the display
      u8g.drawBitmapP(0, 0, 24 / 8, 10, degree_temp_flip);           // 'degree-temp', 24x10px
      if (inches) {
        u8g.drawBitmapP(104, 0, 24 / 8, 10, bitmap_unit_in_flip);
        itoa(tempFint, buffer, 10);
        (tempFint < 0) ? negflag = true : negflag = false;
      } else {
        u8g.drawBitmapP(104, 0, 24 / 8, 10, bitmap_unit_cm_flip);
        itoa(tempCint, buffer, 10);
        (tempCint < 0) ? negflag = true : negflag = false;
      }
      (u8g.getStrWidth(buffer) == 18) ? u8g.drawStr180(21, 7, buffer) : u8g.drawStr180(15, 7, buffer);  // width px
      //if (negflag) u8g.drawBitmapP(18, 5, 3, 1, bitmap_neg);
    }

    // individual pieces of the distance measurement in the 3*4 grid
    u8g.drawBitmapP(24, 17, 32 / 8, 14, sensor[0].measured_distance_cm > dist_step_01 ? bitmap_sensor_01_a_on : bitmap_sensor_01_a_off);
    u8g.drawBitmapP(21, 25, 32 / 8, 16, sensor[0].measured_distance_cm > dist_step_02 ? bitmap_sensor_01_b_on : bitmap_sensor_01_b_off);
    u8g.drawBitmapP(18, 34, 32 / 8, 17, sensor[0].measured_distance_cm > dist_step_03 ? bitmap_sensor_01_c_on : bitmap_sensor_01_c_off);
    u8g.drawBitmapP(16, 43, 32 / 8, 18, sensor[0].measured_distance_cm > dist_step_04 ? bitmap_sensor_01_d_on : bitmap_sensor_01_d_off);

    u8g.drawBitmapP(48, 23, 32 / 8, 9, sensor[1].measured_distance_cm > dist_step_01 ? bitmap_sensor_02_a_on : bitmap_sensor_02_a_off);
    u8g.drawBitmapP(48, 33, 32 / 8, 9, sensor[1].measured_distance_cm > dist_step_02 ? bitmap_sensor_02_b_on : bitmap_sensor_02_b_off);
    u8g.drawBitmapP(47, 42, 32 / 8, 10, sensor[1].measured_distance_cm > dist_step_03 ? bitmap_sensor_02_c_on : bitmap_sensor_02_c_off);
    u8g.drawBitmapP(42, 52, 40 / 8, 10, sensor[1].measured_distance_cm > dist_step_04 ? bitmap_sensor_02_d_on : bitmap_sensor_02_d_off);

    u8g.drawBitmapP(72, 17, 32 / 8, 14, sensor[2].measured_distance_cm > dist_step_01 ? bitmap_sensor_03_a_on : bitmap_sensor_03_a_off);
    u8g.drawBitmapP(74, 25, 32 / 8, 16, sensor[2].measured_distance_cm > dist_step_02 ? bitmap_sensor_03_b_on : bitmap_sensor_03_b_off);
    u8g.drawBitmapP(77, 34, 32 / 8, 17, sensor[2].measured_distance_cm > dist_step_03 ? bitmap_sensor_03_c_on : bitmap_sensor_03_c_off);
    u8g.drawBitmapP(80, 43, 32 / 8, 18, sensor[2].measured_distance_cm > dist_step_04 ? bitmap_sensor_03_d_on : bitmap_sensor_03_d_off);

    for (int i = 0; i < NUMBER_OF_SENSORS; i++) {  // print distance for each the sensor
      // draw a floating black box below the distance number, 0=black
      u8g.setColorIndex(0);
      u8g.drawBox((sensor[i].label_xpos - sensor[i].label_width / 2) - 1, sensor[i].label_ypos - 4, sensor[i].label_width + 2, 8);

      // draw white distance number inside the floating black box 1=white
      (inches) ? itoa(sensor[i].measured_distance_in, buffer, 10) : itoa(sensor[i].measured_distance_cm, buffer, 10);
      u8g.setColorIndex(1);

      // adjust front sensors, because drawStr180 to flip numbers much have different position in the box
      if (rearSensors) {
        u8g.drawStr(sensor[i].label_xpos - sensor[i].label_width / 2, sensor[i].label_ypos - 3, buffer);
      } else {
        u8g.drawStr180(sensor[i].label_xpos + ((sensor[i].label_width) / 2) - 1, sensor[i].label_ypos + 2, buffer);
      }
    }
  } while (u8g.nextPage());
  loopCount++;
}
